'''
对于发送者，执行sendall和send发送消息时，是先将数据发送至自己的网卡写缓冲区，再由缓冲区将数据发送到对方的网卡读缓冲区。
对于接收者，执行recv接收消息时，是从自己的网卡读缓冲区获取数据。

若发送者连续快速的发送了两条消息，接收者在读取时会认为是1条消息的内容，也就是2条消息粘在了一起，即粘包。
'''

# 需要注意的是，不建议使用send,因为send在发送消息时，如果缓冲区满了，就只能写入一部分数据，这时，要通过获取它的返回值，才能
# 知道究竟发了多少数据出去。
# 而sendall则能够循环将内容写如写缓冲区，避免了数据写入不全的情况。


'''
解决粘包的方法：
1.每次发送的消息，都将消息划分为 头部(固定字节的长度) 和 数据 两部分。例如，头部用4个字节表示后面的数据长度。
- 发送数据，先发送数据的长度，再发送数据的内容（或者拼接起来发送）；
- 接收数据，先读取4个字节，就可以知道这个数据包的数据长度，再根据数据的长度来读取数据，从而保证数的完整性。

而对于头部需要一个数字，并固定为4个字节，这个功能需要借助Python的struct包来实现。
'''
